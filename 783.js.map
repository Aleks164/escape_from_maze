{"version":3,"file":"783.js","mappings":"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","sources":["webpack://maze/./src/app/constants.ts","webpack://maze/./src/app/generateMaze/getRandomBorderPosition.ts","webpack://maze/./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","webpack://maze/./node_modules/@babel/runtime/helpers/esm/slicedToArray.js","webpack://maze/./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","webpack://maze/./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","webpack://maze/./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","webpack://maze/./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","webpack://maze/./src/app/generateMaze/breakNaighborWall.ts","webpack://maze/./src/app/generateMaze/getEmptyNeighbor.ts","webpack://maze/./src/app/findExit/getItemClass.ts","webpack://maze/./node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack://maze/./src/app/findExit/insertNextDirectionInMap.ts","webpack://maze/./src/app/findExit/index.ts","webpack://maze/./src/app/findExit/calcCrossCoord.ts","webpack://maze/./src/app/findExit/doStep.ts","webpack://maze/./src/app/findExit/checkAround.ts","webpack://maze/./src/app/findExit/getNextStepDirection.ts","webpack://maze/./src/mazeGeneratorWW.ts","webpack://maze/./src/app/findExit/getNewMazeParams.ts","webpack://maze/./src/app/findExit/getMazeMarkup.ts","webpack://maze/./src/app/generateMaze/index.ts","webpack://maze/./src/app/generateMaze/getNextCellCoord.ts","webpack://maze/./src/app/generateMaze/createMazePatternBySize.ts","webpack://maze/./src/app/findExit/getResultWay.ts","webpack://maze/./src/app/findExit/getStartPosition.ts","webpack://maze/./src/app/findExit/getStartParams.ts"],"sourcesContent":["export enum MESSAGE_TYPES {\n  DRAW_ESCAPING = \"drawEscaping\",\n  DRAW_NEW_MAZE = \"drawNewMaze\",\n}\n","export function getRandomBorderPosition(heightWithBorder: number) {\n  let position = Math.ceil(Math.random() * heightWithBorder);\n  if (position % 2 === 0) position++;\n  if (position === 0) position++;\n  if (position >= heightWithBorder) position = heightWithBorder - 2;\n  return position;\n}\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import { CoordType } from \"../types\";\n\nexport function brakeNaighborWall(\n  mazeMap: string[][],\n  curCell: CoordType,\n  nextCell: CoordType\n) {\n  const [y, x] = curCell;\n  if (curCell[0] > nextCell[0] && mazeMap[y - 1]) {\n    mazeMap[y - 1][x] = \" \";\n  }\n  if (curCell[0] < nextCell[0] && mazeMap[y + 1]) {\n    mazeMap[y + 1][x] = \" \";\n  }\n  if (curCell[1] > nextCell[1] && mazeMap[y][x - 1]) {\n    mazeMap[y][x - 1] = \" \";\n  }\n  if (curCell[1] < nextCell[1] && mazeMap[y][x + 1]) {\n    mazeMap[y][x + 1] = \" \";\n  }\n  return mazeMap;\n}\n","import { CoordType } from \"../../types\";\n\nexport function getEmptyNeighbor(arr: string[][], curCell: CoordType) {\n  const [y, x] = curCell;\n  const result: [number, number][] = [];\n  if (\n    arr[y + 2] &&\n    arr[y + 2][x] === \" \" &&\n    y + 2 !== arr.length - 1 &&\n    y + 2 !== 0\n  ) {\n    result.push([y + 2, x]);\n  }\n  if (\n    arr[y - 2] &&\n    arr[y - 2][x] === \" \" &&\n    y - 2 !== arr.length - 1 &&\n    y - 2 !== 0\n  ) {\n    result.push([y - 2, x]);\n  }\n  if (\n    arr[y][x + 2] &&\n    arr[y][x + 2] === \" \" &&\n    x + 2 !== arr[y].length - 1 &&\n    x + 2 !== 0\n  ) {\n    result.push([y, x + 2]);\n  }\n  if (\n    arr[y][x - 2] &&\n    arr[y][x - 2] === \" \" &&\n    x - 2 !== arr[y].length - 1 &&\n    x - 2 !== 0\n  ) {\n    result.push([y, x - 2]);\n  }\n  return result;\n}\n","export function getItemClass(item: string) {\n  switch (item) {\n    case \"#\": {\n      return \"wall\";\n    }\n    case \"*\": {\n      return \"shortWayColor\";\n    }\n    case \">\":\n    case \"<\":\n    case \"v\":\n    case \"^\": {\n      return \"steps\";\n    }\n    case \"horizontal\": {\n      return \"horizontal\";\n    }\n    case \"vertical\": {\n      return \"vertical\";\n    }\n    default:\n      return \"empty\";\n  }\n}\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","export function insertNextDirectionInMap(\n  string: number,\n  coloumn: number,\n  nextDirection: string,\n  arr: string[]\n) {\n  const newRow = arr[string].split(\"\");\n  newRow[coloumn] = nextDirection;\n  arr[string] = newRow.join(\"\");\n}\n","import { doStep } from \"./doStep\";\nimport { calcCrossCoord } from \"./calcCrossCoord\";\nimport { DirectionType, MapType, StepParamType } from \"../../types\";\n\nexport function makeOneStep(\n  mazeMap: MapType,\n  currentStepParams: StepParamType\n) {\n  let {\n    startPosition,\n    startDirection,\n    coordList,\n    currentWay,\n    listOfCrosses,\n    prev,\n    isEscaped,\n  } = currentStepParams;\n  const { crossingsParamArray } = currentStepParams;\n  if (isEscaped) return currentStepParams;\n  const { nextStep, nextDirection, resultLOg } = doStep(\n    mazeMap,\n    startDirection,\n    startPosition[0],\n    startPosition[1]\n  );\n  if (\n    startPosition[1] === mazeMap[0].length - 1 ||\n    startPosition[0] === mazeMap.length - 1 ||\n    startPosition[0] === 0 ||\n    startPosition[1] === 0\n  ) {\n    currentWay = currentWay.concat(resultLOg);\n    coordList.push([startPosition[0], startPosition[1]]);\n    crossingsParamArray.push({\n      [startPosition.toString()]: {\n        way: currentWay,\n        from: prev,\n        coord: coordList,\n      },\n    });\n    isEscaped = true;\n    return {\n      ...currentStepParams,\n      coordList,\n      currentWay,\n      crossingsParamArray,\n      isEscaped,\n    };\n  }\n  if (nextStep.length > 1 && typeof nextStep !== \"string\") {\n    coordList.push([startPosition[0], startPosition[1]]);\n    const restCrosses = nextStep.splice(1, nextStep.length - 1);\n    listOfCrosses = listOfCrosses.concat(restCrosses);\n    crossingsParamArray.push({\n      [startPosition.toString()]: {\n        way: currentWay,\n        from: prev,\n        coord: coordList,\n      },\n    });\n    currentWay = [];\n    coordList = [];\n    prev = startPosition.toString();\n  }\n  currentWay = currentWay.concat(resultLOg);\n\n  if (nextStep.length) {\n    coordList.push([startPosition[0], startPosition[1]]);\n    [startPosition] = nextStep;\n    startDirection = nextDirection;\n  } else {\n    const crossing = listOfCrosses.shift();\n    coordList = [];\n    if (crossing) {\n      startPosition = crossing;\n      startDirection = mazeMap[crossing[0]][crossing[1]] as DirectionType;\n      prev = calcCrossCoord(startDirection, startPosition).toString();\n    }\n    currentWay = [startDirection];\n  }\n  return {\n    startPosition,\n    startDirection,\n    coordList,\n    currentWay,\n    listOfCrosses,\n    crossingsParamArray,\n    prev,\n    isEscaped,\n  };\n}\n","import { CoordType, DirectionType } from \"../../types\";\n\nexport function calcCrossCoord(direction: DirectionType, coord: CoordType) {\n  let resultCoord: CoordType[] = [];\n  const x = coord[1];\n  const y = coord[0];\n  if (direction === \">\") {\n    resultCoord = resultCoord.concat([y, x - 1]);\n  }\n  if (direction === \"<\") {\n    resultCoord = resultCoord.concat([y, x + 1]);\n  }\n  if (direction === \"^\") {\n    resultCoord = resultCoord.concat([y + 1, x]);\n  }\n  if (direction === \"v\") {\n    resultCoord = resultCoord.concat([y - 1, x]);\n  }\n  return resultCoord;\n}\n","import { DirectionType, MapType } from \"../../types\";\nimport { checkAround } from \"./checkAround\";\nimport { getNextStepDirection } from \"./getNextStepDirection\";\n\nexport function doStep(\n  mazeMap: MapType,\n  curDirecation: DirectionType,\n  y: number,\n  x: number\n) {\n  const check = checkAround(y, x, mazeMap);\n  if (!check.length)\n    return {\n      nextStep: [],\n      nextDirection: \"\" as DirectionType,\n      resultLOg: [],\n    };\n  const [nextY, nextX] = check[0];\n  const { nextDirection, resultLOg } = getNextStepDirection(\n    [y, x],\n    [nextY, nextX],\n    curDirecation\n  );\n  return {\n    nextStep: check,\n    nextDirection,\n    resultLOg,\n  };\n}\n","import { CoordType, MapType } from \"../../types\";\nimport { insertNextDirectionInMap } from \"./insertNextDirectionInMap\";\n\nexport function checkAround(y: number, x: number, mazeMap: MapType) {\n  const emptyWay: CoordType[] = [];\n\n  if (mazeMap[y + 1] && mazeMap[y + 1][x] === \" \") {\n    emptyWay.push([y + 1, x]);\n    insertNextDirectionInMap(y + 1, x, \"v\", mazeMap);\n  }\n  if (mazeMap[y - 1] && mazeMap[y - 1][x] === \" \") {\n    emptyWay.push([y - 1, x]);\n    insertNextDirectionInMap(y - 1, x, \"^\", mazeMap);\n  }\n  if (mazeMap[y][x + 1] === \" \") {\n    emptyWay.push([y, x + 1]);\n    insertNextDirectionInMap(y, x + 1, \">\", mazeMap);\n  }\n  if (mazeMap[y][x - 1] === \" \") {\n    emptyWay.push([y, x - 1]);\n    insertNextDirectionInMap(y, x - 1, \"<\", mazeMap);\n  }\n  return emptyWay;\n}\n","import { CoordType, DirectionType } from \"../../types\";\n\nexport function getNextStepDirection(\n  curPosition: CoordType,\n  NextPosition: CoordType,\n  curDirection: DirectionType\n) {\n  const resultLOg: string[] = [];\n  let nextDirection: DirectionType = \">\";\n  if (curPosition[0] > NextPosition[0]) nextDirection = \"^\"; // top\n  if (curPosition[0] < NextPosition[0]) nextDirection = \"v\"; // bottom\n  if (curPosition[1] > NextPosition[1]) nextDirection = \"<\"; // left\n  if (curPosition[1] < NextPosition[1]) nextDirection = \">\"; // right\n\n  if (curDirection === nextDirection) resultLOg.push(\"F\");\n  else if (curDirection === \">\") {\n    if (nextDirection === \"<\") resultLOg.push(\"B\", \"F\");\n    if (nextDirection === \"^\") resultLOg.push(\"L\", \"F\");\n    if (nextDirection === \"v\") resultLOg.push(\"R\", \"F\");\n  } else if (curDirection === \"<\") {\n    if (nextDirection === \">\") resultLOg.push(\"B\", \"F\");\n    if (nextDirection === \"v\") resultLOg.push(\"L\", \"F\");\n    if (nextDirection === \"^\") resultLOg.push(\"R\", \"F\");\n  } else if (curDirection === \"v\") {\n    if (nextDirection === \"^\") resultLOg.push(\"B\", \"F\");\n    if (nextDirection === \"<\") resultLOg.push(\"R\", \"F\");\n    if (nextDirection === \">\") resultLOg.push(\"L\", \"F\");\n  } else if (curDirection === \"^\") {\n    if (nextDirection === \"v\") resultLOg.push(\"B\", \"F\");\n    if (nextDirection === \">\") resultLOg.push(\"R\", \"F\");\n    if (nextDirection === \"<\") resultLOg.push(\"L\", \"F\");\n  }\n  return { nextDirection, resultLOg };\n}\n","import { MESSAGE_TYPES } from \"./app/constants\";\nimport { getNewMazeParams } from \"./app/findExit/getNewMazeParams\";\nimport { getResultWay } from \"./app/findExit/getResultWay\";\nimport { OnPostMessageParamsType } from \"./types\";\n\nconst mazesContainer: Record<string, any> = {};\n\nself.onmessage = ({\n  data: { mazeParams, key, type },\n}: OnPostMessageParamsType) => {\n  switch (type) {\n    case MESSAGE_TYPES.DRAW_NEW_MAZE: {\n      const { height, width } = mazeParams;\n      const { mazeMarkup, newMaze } = getNewMazeParams(height, width);\n      mazesContainer[key] = newMaze;\n      self.postMessage({ mazeMarkup, type });\n      break;\n    }\n    case MESSAGE_TYPES.DRAW_ESCAPING: {\n      const newMaze = mazesContainer[key];\n      const crossingsParamArray = getResultWay(newMaze);\n      self.postMessage({ crossingsParamArray, newMaze, type });\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n};\n","import { createMazePatternBySize } from \"../generateMaze/createMazePatternBySize\";\nimport { mazeGenerator } from \"../generateMaze\";\nimport { MapType, NewMazeParamType } from \"../../types\";\nimport { getMazeMarkup } from \"./getMazeMarkup\";\n\nexport function getNewMazeParams(\n  height: number,\n  wight: number\n): NewMazeParamType {\n  const startMaze = mazeGenerator(createMazePatternBySize(height, wight));\n\n  const newMaze: MapType = self.structuredClone(startMaze);\n  return { newMaze, mazeMarkup: getMazeMarkup(startMaze) };\n}\n","import { getItemClass } from \"./getItemClass\";\n\nexport function getMazeMarkup(arr: string[]) {\n  return `<div class=\"mazeRow\"><div class=\"mazeRow\" style=\"grid-template-columns: repeat(${\n    arr[0].length + 1\n  },15px); \">\n  ${Array(arr[0].length)\n    .fill(0)\n    .map((_, columnNumber) => {\n      let emptyCell = \"\";\n      if (columnNumber === 0) emptyCell = \"<div> </div>\";\n      return `${emptyCell}<div  class=${getItemClass(\"vertical\")}>${\n        columnNumber + 1\n      }</div>`;\n    })\n    .join(\"\")}</div>\n  ${arr\n    .map(\n      (row, rowNumber) =>\n        `<div class=\"mazeRow\" style=\"grid-template-columns: repeat(${\n          arr[0].length + 1\n        },15px); \">${row\n          .split(\"\")\n          .map((el, coloumnNumber) => {\n            let numbers = \"\";\n            if (coloumnNumber === 0)\n              numbers = `<div class=${getItemClass(\"horizontal\")}>${\n                rowNumber + 1\n              }</div>`;\n            return `${numbers}<div class=${getItemClass(el)}>${\n              el || \".\"\n            }</div>`;\n          })\n          .join(\"\")}</div>`\n    )\n    .join(\"\")}</div>`;\n}\n","import { brakeNaighborWall } from \"./breakNaighborWall\";\nimport { getNextCellCoord } from \"./getNextCellCoord\";\nimport { getEmptyNeighbor } from \"./getEmptyNeighbor\";\nimport { getRandomBorderPosition } from \"./getRandomBorderPosition\";\nimport { CoordType } from \"../../types\";\n\nexport function mazeGenerator(arr: string[][]) {\n  const startCell: CoordType = [1, 1];\n  let curCell = startCell;\n  const cellsWithEmptyNeighborStack = [startCell];\n  while (cellsWithEmptyNeighborStack.length) {\n    arr[curCell[0]][curCell[1]] = \"*\";\n    const emptyNeighbors = getEmptyNeighbor(arr, curCell);\n    if (emptyNeighbors.length === 0) {\n      curCell = cellsWithEmptyNeighborStack.shift()!;\n      // eslint-disable-next-line no-continue\n      continue;\n    } else if (emptyNeighbors.length > 1) {\n      cellsWithEmptyNeighborStack.push(curCell);\n    }\n\n    const nextCell = getNextCellCoord(emptyNeighbors);\n    brakeNaighborWall(arr, curCell, nextCell);\n    curCell = nextCell;\n  }\n  const start = getRandomBorderPosition(arr.length);\n  arr[start][1] = \">\";\n  const resultArr = arr.map((el) => el.join(\"\").replaceAll(\"*\", \" \"));\n  return resultArr;\n}\n","import { CoordType } from \"../../types\";\n\nexport function getNextCellCoord(variants: CoordType[]) {\n  const variantsLength = variants.length;\n  const rndmVariants = Math.floor(Math.random() * variantsLength);\n  return variants[rndmVariants];\n}\n","import { getRandomBorderPosition } from \"./getRandomBorderPosition\";\n\nexport function createMazePatternBySize(width: number, height: number) {\n  const widthWithBorder = width * 2 + 1;\n  const heightWithBorder = height * 2 + 1;\n  let rowsArray = Array(heightWithBorder).fill(\"\");\n\n  const end = getRandomBorderPosition(heightWithBorder);\n  rowsArray = rowsArray.map((_, i, arr) => {\n    if (i === 0 || i === arr.length - 1 || i % 2 === 0)\n      return Array(widthWithBorder).fill(\"#\");\n\n    return Array(widthWithBorder)\n      .fill(\" \")\n      .map((col, index, arrCol) => {\n        if (i === end && index === widthWithBorder - 1) return \" \";\n        if (index % 2 === 0 || index === 0 || index === arrCol.length - 1)\n          return \"#\";\n        return `${col}`;\n      });\n  });\n  return rowsArray;\n}\n","import { makeOneStep } from \".\";\nimport { getStartParams } from \"./getStartParams\";\nimport { getStartPosition } from \"./getStartPosition\";\nimport { MapType, StepParamType } from \"../../types\";\n\nexport function getResultWay(mazeMap: MapType) {\n  const startParam = getStartPosition(mazeMap);\n  const stepParam = getStartParams();\n  const isEscaped = false;\n  let everyStepParam: StepParamType = {\n    ...startParam,\n    ...stepParam,\n    isEscaped,\n  };\n  while (!everyStepParam.isEscaped) {\n    everyStepParam = makeOneStep(mazeMap, everyStepParam);\n  }\n  return everyStepParam.crossingsParamArray;\n}\n","import { CoordType, DirectionType, MapType } from \"../../types\";\n\nexport function getStartPosition(mazeMap: MapType) {\n  const startVariants = [\"<\", \"^\", \">\", \"v\"];\n  let startPosition: CoordType = [0, 0];\n  let startDirection = \"\" as DirectionType;\n  for (let y = 0; y < mazeMap.length; y++) {\n    for (let x = 0; x < mazeMap[y].length; x++) {\n      if (startVariants.indexOf(mazeMap[y][x]) >= 0) {\n        startPosition = [y, x];\n        startDirection = mazeMap[y][x] as DirectionType;\n        break;\n      }\n      if (startDirection) break;\n    }\n  }\n  return {\n    startPosition,\n    startDirection,\n  };\n}\n","import { StartParamType } from \"../../types\";\n\nexport function getStartParams(): StartParamType;\n\nexport function getStartParams() {\n  return {\n    coordList: [],\n    currentWay: [],\n    listOfCrosses: [],\n    crossingsParamArray: [{ start: { way: [], from: null, coord: [] } }],\n    prev: \"start\",\n  } as StartParamType;\n}\n"],"names":["MESSAGE_TYPES","getRandomBorderPosition","heightWithBorder","position","Math","ceil","random","_arrayLikeToArray","arr","len","length","i","arr2","Array","_slicedToArray","isArray","_i","Symbol","iterator","_s","_e","_arr","_n","_d","call","next","done","push","value","err","o","minLen","n","Object","prototype","toString","slice","constructor","name","from","test","TypeError","brakeNaighborWall","mazeMap","curCell","nextCell","y","x","getEmptyNeighbor","result","getItemClass","item","_defineProperty","obj","key","defineProperty","enumerable","configurable","writable","insertNextDirectionInMap","string","coloumn","nextDirection","newRow","split","join","makeOneStep","currentStepParams","startPosition","startDirection","coordList","currentWay","listOfCrosses","prev","isEscaped","crossingsParamArray","direction","coord","resultCoord","curDirecation","check","emptyWay","checkAround","nextStep","resultLOg","curPosition","NextPosition","curDirection","doStep","concat","way","restCrosses","splice","crossing","shift","mazesContainer","self","onmessage","height","wight","startMaze","data","mazeParams","type","DRAW_NEW_MAZE","width","variants","variantsLength","startCell","cellsWithEmptyNeighborStack","emptyNeighbors","floor","map","el","replaceAll","mazeGenerator","widthWithBorder","rowsArray","fill","end","_","col","index","arrCol","createMazePatternBySize","newMaze","structuredClone","mazeMarkup","columnNumber","emptyCell","row","rowNumber","coloumnNumber","numbers","postMessage","DRAW_ESCAPING","startParam","startVariants","indexOf","getStartPosition","everyStepParam","start","getResultWay"],"sourceRoot":""}